#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba32f, binding = 0) readonly uniform image2D ElevationRead;
layout (rgba32f, binding = 1) writeonly uniform image2D ElevationWrite;
layout (rgba32f, binding = 2) readonly uniform image2D GradientRead;

layout (rgba32f, binding = 7) writeonly uniform image2D DebugImage;

uniform ivec2 DebugPixel0;
uniform ivec2 DebugPixel1;

layout (std430, binding = 10) buffer DebugBuffer{ vec4 DebugData[]; };

const uint MASK_ELEVATION = 1u << 0;
const uint MASK_GRADIENT  = 1u << 1;
const uint MASK_NOISE     = 1u << 2;

bool IsValidFloat(float x) {
    return (x == x) && (abs(x) < 1e20);
}

void main(){

	ivec2 p = ivec2(gl_GlobalInvocationID.xy);

	if(p.x >= imageSize(ElevationRead).x || p.y >= imageSize(ElevationRead).y){
		return;
	}

	uint mask = uint(imageLoad(ElevationRead, p).a + 0.5);

	bool HasElevationMask = (mask & MASK_ELEVATION) != 0u;
	bool HasGradientMask  = (mask & MASK_GRADIENT)  != 0u;
	bool HasNoiseMask = (mask & MASK_NOISE) != 0u;

	float Alpha = 0.0f;
	float Beta = 0.0f;

	if(HasElevationMask){
		Alpha = 0.0f;
		Beta = 0.0f;
	}
	else if(HasGradientMask){
		Alpha = 0.5f;
		Beta = 0.5f;
	}
	else{
		Alpha = 1.0f;
		Beta = 0.0f;
	}


	ivec2 Left = clamp(p + ivec2(-1, 0), ivec2(0), imageSize(ElevationRead) - ivec2(1));
	ivec2 Right = clamp(p + ivec2(1, 0), ivec2(0), imageSize(ElevationRead) - ivec2(1));
	ivec2 Down = clamp(p + ivec2(0, -1), ivec2(0), imageSize(ElevationRead) - ivec2(1));
	ivec2 Up = clamp(p + ivec2(0, 1), ivec2(0), imageSize(ElevationRead) - ivec2(1));

	float F_L = 0.25f * (imageLoad(ElevationRead, Left).r +
						imageLoad(ElevationRead, Right).r +
						imageLoad(ElevationRead, Down).r +
						imageLoad(ElevationRead, Up).r);

	float F_I = imageLoad(ElevationRead, p).r;

	float F_G = F_I;

	vec3 Normal = imageLoad(GradientRead, p).rgb;

	float Len = length(Normal.xy);

	float F_N = 0.0f;

	if(Len > 0.00001f){
		vec2 n = normalize(Normal.xy);
		
		ivec2 nxp = ivec2(-int(sign(n.x)), 0);
	    ivec2 nyp = ivec2(0, -int(sign(n.y)));

		float Fx = imageLoad(ElevationRead, clamp(p + nxp, ivec2(0), imageSize(ElevationRead) - ivec2(1))).r;
		float Fy = imageLoad(ElevationRead, clamp(p + nyp, ivec2(0), imageSize(ElevationRead) - ivec2(1))).r;

		F_N = n.x * n.x * Fx + n.y * n.y * Fy;

		F_G = F_N + Normal.z;
	}
	else {
		F_G = F_L;
	}

	float e = F_G - F_I;

	float NewHeight = Alpha * F_L + Beta * F_G + (1.0f - Alpha - Beta) * F_I;

	if(!IsValidFloat(NewHeight)){
		NewHeight = imageLoad(ElevationRead, p).r;
		return;
	}

	if(p == DebugPixel0){
		DebugData[0] = vec4(F_L, F_G, Alpha, Beta);
	}
	if(p == DebugPixel1){
		DebugData[1] = vec4(F_L, F_G, Alpha, Beta);
	}

	imageStore(DebugImage, p, vec4(F_I, F_N, F_G, NewHeight));

	//imageStore(ElevationWrite, p, vec4(NewHeight) );

	// Noise diffusion

	float NewAmplitude = 0.0f;
	float NewRoughness = 0.0f;

	if(HasNoiseMask) {
		NewAmplitude = imageLoad(ElevationRead, p).g;
		NewRoughness = imageLoad(ElevationRead, p).b;
	}
	else{
		NewAmplitude = 0.25f * (imageLoad(ElevationRead, Left).g +
								imageLoad(ElevationRead, Right).g +
								imageLoad(ElevationRead, Down).g +
								imageLoad(ElevationRead, Up).g);

		NewRoughness = 0.25f * (imageLoad(ElevationRead, Left).b +
								imageLoad(ElevationRead, Right).b +
								imageLoad(ElevationRead, Down).b +
								imageLoad(ElevationRead, Up).b);
	}

	imageStore(ElevationWrite, p, vec4(NewHeight, NewAmplitude, NewRoughness, float(mask)));

	// Noise diffusion

	return;

}