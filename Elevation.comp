#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;

layout (r32f, binding = 0) readonly uniform image2D ElevationRead;
layout (r32f, binding = 1) writeonly uniform image2D ElevationWrite;
layout (rgba32f, binding = 2) readonly uniform image2D GradientRead;
layout (r8ui, binding = 6) readonly uniform uimage2D ConstraintMaskImage;

uniform ivec2 DebugPixel0;
uniform ivec2 DebugPixel1;

layout (std430, binding = 10) buffer DebugBuffer{ vec4 DebugData[]; };

const uint MASK_ELEVATION = 1u << 0;
const uint MASK_GRADIENT  = 1u << 1;
const uint MASK_NOISE     = 1u << 2;

bool IsValidFloat(float x) {
    return (x == x) && (abs(x) < 1e20);
}

void main(){

	ivec2 p = ivec2(gl_GlobalInvocationID.xy);

	if(p.x >= imageSize(ElevationRead).x || p.y >= imageSize(ElevationRead).y){
		return;
	}

	bool HasElevationMask = (imageLoad(ConstraintMaskImage, p).r & MASK_ELEVATION) != 0u;
	bool HasGradientMask  = (imageLoad(ConstraintMaskImage, p).r & MASK_GRADIENT)  != 0u;

	float Alpha, Beta;

	if(HasElevationMask){
		Alpha = 0.0f;
		Beta = 0.0f;
	}
	else if(HasGradientMask){
		Alpha = 0.5f;
		Beta = 0.5f;

	}
	else{
		Alpha = 1.0f;
		Beta = 0.0f;
	}

	ivec2 Left = p + ivec2(-1,  0);
	if(Left.x < 0) Left.x = 0;
	ivec2 Right= p + ivec2( 1,  0);
	if(Right.x >= imageSize(GradientRead).x) Right.x = imageSize(GradientRead).x - 1;
	ivec2 Down = p + ivec2( 0, -1);
	if(Down.y < 0) Down.y = 0;
	ivec2 Up   = p + ivec2( 0,  1);
	if(Up.y >= imageSize(GradientRead).y) Up.y = imageSize(GradientRead).y - 1;

	float LeftHeight = imageLoad(ElevationRead, Left).r;
	float RightHeight = imageLoad(ElevationRead, Right).r;
	float DownHeight = imageLoad(ElevationRead, Down).r; 
	float UpHeight = imageLoad(ElevationRead, Up).r;

	float LaplacianHeight = 0.25 * (LeftHeight + RightHeight + DownHeight + UpHeight);

	vec3 Gradient = imageLoad(GradientRead, p).rgb;

	vec2 n = vec2(0.0f, 0.0f);
	float GradientNorm = Gradient.z;
	if(GradientNorm > 1e-6f) n = normalize(Gradient.xy);

	ivec2 px = p - ivec2(sign(n.x), 0);
	ivec2 py = p - ivec2(0, sign(n.y));

	px = clamp(px, ivec2(0,0), imageSize(ElevationRead) - 1);
	py = clamp(py, ivec2(0,0), imageSize(ElevationRead) - 1);

	float FN = n.x * n.x * (abs(n.x) > 0.0 ? imageLoad(ElevationRead, px).r : 0) +
		       n.y * n.y * (abs(n.y) > 0.0 ? imageLoad(ElevationRead, py).r : 0);

	float FG = FN + GradientNorm;
	
	float NewHeight = Alpha * LaplacianHeight + Beta * FG + (1.0f - Alpha - Beta) * imageLoad(ElevationRead, p).r;

	if(!IsValidFloat(NewHeight)){
		NewHeight = imageLoad(ElevationRead, p).r;
	}

	if(p == DebugPixel0){
		DebugData[0] = vec4(imageLoad(ElevationRead, p).r, FN, FG, NewHeight);
	}
	if(p == DebugPixel1){
		DebugData[1] = vec4(imageLoad(ElevationRead, p).r, FN, FG, NewHeight);
	}

	imageStore(ElevationWrite, p, vec4(NewHeight) );

}