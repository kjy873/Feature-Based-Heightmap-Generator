#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;

layout (r32f, binding = 0) readonly uniform image2D ElevationRead;
layout (r32f, binding = 1) writeonly uniform image2D ElevationWrite;
layout (rgba32f, binding = 2) readonly uniform image2D GradientRead;
layout (r8ui, binding = 6) readonly uniform uimage2D ConstraintMaskImage;

uniform ivec2 DebugPixel0;
uniform ivec2 DebugPixel1;

layout (std430, binding = 10) buffer DebugBuffer{ vec4 DebugData[]; };

const uint MASK_ELEVATION = 1u << 0;
const uint MASK_GRADIENT  = 1u << 1;
const uint MASK_NOISE     = 1u << 2;

bool IsValidFloat(float x) {
    return (x == x) && (abs(x) < 1e20);
}

void main(){

	ivec2 p = ivec2(gl_GlobalInvocationID.xy);

	if(p.x >= imageSize(ElevationRead).x || p.y >= imageSize(ElevationRead).y){
		return;
	}

	bool HasElevationMask = (imageLoad(ConstraintMaskImage, p).r & MASK_ELEVATION) != 0u;
	bool HasGradientMask  = (imageLoad(ConstraintMaskImage, p).r & MASK_GRADIENT)  != 0u;

	
	ivec2 Offsets[4] = ivec2[](ivec2(-1, 0), ivec2(1, 0), ivec2(0, -1), ivec2(0, 1));

	float Sum = 0.0f;

	for(int i = 0; i < 4; i++){
		ivec2 NeighborPixel = clamp(p + Offsets[i], ivec2(0), imageSize(ElevationRead) - ivec2(1));

		float NeighborHeight = imageLoad(ElevationRead, NeighborPixel).r;

		vec3 NeighborGradient = imageLoad(GradientRead, NeighborPixel).rgb;
		vec2 Gradient = NeighborGradient.xy * NeighborGradient.z;

		vec2 Direction = vec2(-Offsets[i]);

		Sum += (NeighborHeight + dot(Gradient, Direction));
	}

	float NewHeight = 0.25f * Sum;



	if(!IsValidFloat(NewHeight)){
		NewHeight = imageLoad(ElevationRead, p).r;
	}

	if(p == DebugPixel0){
		DebugData[0] = vec4(float(imageLoad(ConstraintMaskImage, p).r), 0.0f, 0.0f, 0.0f);
	}
	if(p == DebugPixel1){
		DebugData[1] = vec4(float(imageLoad(ConstraintMaskImage, p).r), 0.0f, 0.0f, 0.0f);
	}

	if(HasElevationMask){
		NewHeight = imageLoad(ElevationRead, p).r;
	}

	imageStore(ElevationWrite, p, vec4(NewHeight) );

}