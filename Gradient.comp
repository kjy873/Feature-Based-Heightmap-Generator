#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba32f, binding = 2) readonly uniform image2D GradientRead;
layout (rgba32f, binding = 3) writeonly uniform image2D GradientWrite;
layout (r8ui, binding = 6) readonly uniform uimage2D ConstraintMaskImage;

const uint MASK_ELEVATION = 1u << 0;
const uint MASK_GRADIENT  = 1u << 1;
const uint MASK_NOISE     = 1u << 2;

void main(){

	ivec2 p = ivec2(gl_GlobalInvocationID.xy);
	if(p.x >= imageSize(GradientRead).x || p.y >= imageSize(GradientRead).y){
		return;
	}

	ivec2 Left = p + ivec2(-1,  0);
	if(Left.x < 0) Left.x = 0;
	ivec2 Right= p + ivec2( 1,  0);
	if(Right.x >= imageSize(GradientRead).x) Right.x = imageSize(GradientRead).x - 1;
	ivec2 Down = p + ivec2( 0, -1);
	if(Down.y < 0) Down.y = 0;
	ivec2 Up   = p + ivec2( 0,  1);
	if(Up.y >= imageSize(GradientRead).y) Up.y = imageSize(GradientRead).y - 1;

	vec4 Gc = imageLoad(GradientRead, p);

	uint mask = imageLoad(ConstraintMaskImage, p).r;

	bool HasGradientConstraint = (mask & MASK_GRADIENT) != 0u;
	bool HasElevationConstraint = (mask & MASK_ELEVATION) != 0u;

	// 항상 Laplace diffusion
	vec4 G_L = 0.25 * (
    imageLoad(GradientRead, Left) +
    imageLoad(GradientRead, Right) +
    imageLoad(GradientRead, Down) +
    imageLoad(GradientRead, Up)
	);

	float Magnitude = 0.0; // 기본값 0 (둘 다 아닐 때)

	if (HasGradientConstraint) {
		Magnitude = Gc.z; // Gradient 제약이 있으면 현재 값(Gc)의 z 유지
	}	 
	else if (HasElevationConstraint) {
    		Magnitude = G_L.z; 
	} 
	else {
		Magnitude = 0.0f; // 둘 다 아닐 때 0
	}

	imageStore(GradientWrite, p, vec4(G_L.x, G_L.y, Magnitude, G_L.w));

	return;

}