#version 430 core

layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba32f, binding = 0) readonly uniform image2D ElevationOld;
layout (rgba32f, binding = 1) readonly uniform image2D ElevationNew;
layout (rgba32f, binding = 2) writeonly uniform image2D ResidualFine;
layout (rgba32f, binding = 3) writeonly uniform image2D CoarseWrite;
layout (rgba32f, binding = 4) writeonly uniform image2D ResidualCoarse;
layout (rgba32f, binding = 5) readonly uniform image2D GradientRead;
layout (rgba32f, binding = 6) writeonly uniform image2D GradientWrite;

const uint MASK_ELEVATION = 1u << 0;
const uint MASK_GRADIENT  = 1u << 1;
const uint MASK_NOISE     = 1u << 2;

float ElevationResidual(float NewH, float OldH, uint Mask){
	if((Mask & MASK_ELEVATION) != 0u){
		return 0.0f;
	}
	return NewH - OldH;

}

vec3 DownsampleGradient(vec3 P00, vec3 P01, vec3 P10, vec3 P11){

	vec2 N00 = normalize(P00.rg);
	vec2 N01 = normalize(P01.rg);
	vec2 N10 = normalize(P10.rg);
	vec2 N11 = normalize(P11.rg);

	float W00 = P00.b;
	float W01 = P01.b;
	float W10 = P10.b;
	float W11 = P11.b;

	vec2 RefN = N00;
	float RefW = W00;

	if(W01 > RefW){ RefN = N01; RefW = W01; }
	if(W10 > RefW){ RefN = N10; RefW = W10; }
	if(W11 > RefW){ RefN = N11; RefW = W11; }

	float SumW = W00 + W01 + W10 + W11;
	if (SumW <= 1e-6f || RefW <= 1e-6f || length(RefN) <= 1e-6f){ return vec3(0.0f); }

	if(W00 > 0.0f && dot(N00, RefN) < 0.0f) N00 = -N00;
	if(W01 > 0.0f && dot(N01, RefN) < 0.0f) N01 = -N01;
	if(W10 > 0.0f && dot(N10, RefN) < 0.0f) N10 = -N10;
	if(W11 > 0.0f && dot(N11, RefN) < 0.0f) N11 = -N11;

	vec2 Sum = W00 * N00 + W01 * N01 + W10 * N10 + W11 * N11;

	float len = length(Sum);
	vec2 CoarseN = (len > 1e-6f) ? (Sum / len) : RefN;

	float Count =
        (W00 > 0.0 ? 1.0 : 0.0) +
        (W01 > 0.0 ? 1.0 : 0.0) +
        (W10 > 0.0 ? 1.0 : 0.0) +
        (W11 > 0.0 ? 1.0 : 0.0);
	float CoarseNorm = (Count > 0.0f) ? (SumW / Count) : 0.0f;
	

	return vec3(CoarseN, CoarseNorm);
}

void main(){
	ivec2 p = ivec2(gl_GlobalInvocationID.xy);

	if(p.x >= imageSize(CoarseWrite).x || p.y >= imageSize(CoarseWrite).y){
		return;
	}



	ivec2 p00 = p * 2;
	ivec2 p01 = p00 + ivec2(0, 1);
	ivec2 p10 = p00 + ivec2(1, 0);
	ivec2 p11 = p00 + ivec2(1, 1);

	p00 = clamp(p00, ivec2(0), imageSize(ElevationOld) - ivec2(1));
	p01 = clamp(p01, ivec2(0), imageSize(ElevationOld) - ivec2(1));
	p10 = clamp(p10, ivec2(0), imageSize(ElevationOld) - ivec2(1));
	p11 = clamp(p11, ivec2(0), imageSize(ElevationOld) - ivec2(1));

	uint MaskP00 = uint(imageLoad(ElevationOld, p00).a + 0.5);
	uint MaskP01 = uint(imageLoad(ElevationOld, p01).a + 0.5);
	uint MaskP10 = uint(imageLoad(ElevationOld, p10).a + 0.5);
	uint MaskP11 = uint(imageLoad(ElevationOld, p11).a + 0.5);

	float ResidualP00 = ElevationResidual(imageLoad(ElevationNew, p00).r, imageLoad(ElevationOld, p00).r, MaskP00);
	float ResidualP01 = ElevationResidual(imageLoad(ElevationNew, p01).r, imageLoad(ElevationOld, p01).r, MaskP01);
	float ResidualP10 = ElevationResidual(imageLoad(ElevationNew, p10).r, imageLoad(ElevationOld, p10).r, MaskP10);
	float ResidualP11 = ElevationResidual(imageLoad(ElevationNew, p11).r, imageLoad(ElevationOld, p11).r, MaskP11);


	// Gradient
	
	vec3 CoarseGradient = DownsampleGradient(
		imageLoad(GradientRead, p00).rgb,
		imageLoad(GradientRead, p01).rgb,
		imageLoad(GradientRead, p10).rgb,
		imageLoad(GradientRead, p11).rgb
	);

	// Gradient

	// fine residual debug, 전체 패스 완성 후 주석 처리
	imageStore(ResidualFine, p00, vec4(ResidualP00, 0.0f, 0.0f, float(MaskP00)));
	imageStore(ResidualFine, p01, vec4(ResidualP01, 0.0f, 0.0f, float(MaskP01)));
	imageStore(ResidualFine, p10, vec4(ResidualP10, 0.0f, 0.0f, float(MaskP10)));
	imageStore(ResidualFine, p11, vec4(ResidualP11, 0.0f, 0.0f, float(MaskP11)));
	// fine residual debug

	float ResidualAvrg = (ResidualP00 + ResidualP01 + ResidualP10 + ResidualP11) * 0.25f;

	uint Mask = MaskP00 | MaskP01 | MaskP10 | MaskP11;



	// noise도 residual 계산한다면 마스크 범위에서 0

	imageStore(ResidualCoarse, p, vec4(ResidualAvrg, 0.0f, 0.0f, float(Mask)));
	imageStore(GradientWrite, p, vec4(CoarseGradient, 0.0f));

	//imageStore(CoarseWrite, p, vec4(ResidualAvrg, 0.0f, 0.0f, float(Mask)));
}